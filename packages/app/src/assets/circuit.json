{
    "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
    "hash": 9971681726068345997,
    "abi": {
        "parameters": [
            {
                "name": "guess",
                "type": {
                    "kind": "array",
                    "length": 4,
                    "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
                },
                "visibility": "public"
            },
            {
                "name": "solution",
                "type": {
                    "kind": "array",
                    "length": 4,
                    "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
                },
                "visibility": "private"
            },
            { "name": "salt", "type": { "kind": "field" }, "visibility": "private" },
            {
                "name": "solution_hash",
                "type": { "kind": "field" },
                "visibility": "public"
            },
            {
                "name": "num_hit",
                "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
                "visibility": "public"
            },
            {
                "name": "num_blow",
                "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
                "visibility": "public"
            }
        ],
        "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" },
        "error_types": {
            "2920182694213909827": {
                "error_kind": "string",
                "string": "attempt to subtract with overflow"
            },
            "5019202896831570965": {
                "error_kind": "string",
                "string": "attempt to add with overflow"
            },
            "7233212735005103307": {
                "error_kind": "string",
                "string": "attempt to multiply with overflow"
            }
        }
    },
    "bytecode": "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",
    "debug_symbols": "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",
    "file_map": {
        "18": {
            "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
            "path": "std/field/mod.nr"
        },
        "22": {
            "source": "// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n",
            "path": "std/hash/poseidon/bn254/perm.nr"
        },
        "23": {
            "source": "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
            "path": "std/hash/poseidon/bn254.nr"
        },
        "24": {
            "source": "pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n",
            "path": "std/hash/poseidon/mod.nr"
        },
        "61": {
            "source": "mod range_proof;\n\nuse range_proof::range_proof;\nuse std;\n\nfn main(\n  guess: pub [u8; 4],\n  solution: [u8; 4],\n  salt: Field,\n  solution_hash: pub Field,\n  num_hit: pub u8,\n  num_blow: pub u8,\n) -> pub Field {\n    // Minimum ascii character allowed\n    let min_ascii_char = 65;\n    // Maximum ascii character allowed\n    let max_ascii_char = 90;\n\n    // Assert that the guess and solution char are all between 65 and 90.\n    for i in 0..4 {\n        assert(range_proof(min_ascii_char, guess[i], max_ascii_char));\n        assert(range_proof(min_ascii_char, solution[i], max_ascii_char));\n\n        // Assert that the guess and solution char are all different\n        for j in (i+1)..4 {\n            assert(guess[i] != guess[j]);\n            assert(solution[i] != solution[j]);\n        }\n    }\n\n    // Count hit & blow\n    let mut hit = 0;\n    let mut blow = 0;\n    \n    for i in 0..4 {\n        for j in 0..4 {\n            let eq = if (guess[i] == solution[j]) {\n                1\n            } else {\n                0\n            };\n\n            blow += eq;\n\n            if (i == j) {\n                hit += eq;\n                blow -= eq;\n            }\n        }\n    }\n\n    // Assert the number of hit\n    assert(hit == num_hit);\n\n    // Assert the number of blow\n    assert(blow == num_blow);\n\n    // Verify that the hash of the solution matches solution_hash\n    let prep_solution: Field = (solution[0] as u32 + \n                        solution[1] as u32 * 256 +\n                        solution[2] as u32 * 256 * 256 +\n                        solution[3] as u32 * 256 * 256 * 256).into();\n\n    let hash = std::hash::poseidon::bn254::hash_2([prep_solution, salt]);\n\n    assert(solution_hash == hash);\n    \n    hash\n}\n",
            "path": "/Users/truthixify/dev/starknet/garaga/m/packages/circuit/src/main.nr"
        },
        "62": {
            "source": "// range proof function to check a <= x <= b\npub fn range_proof(a: u8, x: u8, b: u8) -> bool {\n    x >= a & x <= b\n}",
            "path": "/Users/truthixify/dev/starknet/garaga/m/packages/circuit/src/range_proof.nr"
        }
    },
    "names": ["main"],
    "brillig_names": ["directive_integer_quotient", "directive_invert"]
}
